---
layout: post
title: Database Transactions with Postgres and ActiveRecord
author: Lucas Moore
---

In refactoring my [anagram API project](), I was asked how to handle multiple requests that were attempting to `POST` words to the database and shared a key.
As the code currently is, one request would pull out and modify the table row. The second concurrent request would therefore be silently lost.
That's no good.

Here's the code I had.

```ruby
data['words'].each do |word|
  anagram = Anagram.find_or_create_by(key: find_key(word))
  if anagram.words.exclude?(word)
    anagram.words.push(word)
  end
  anagram.save
end
```

So how can this be resolved? With a [transaction](http://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html), of course!

A transaction is a block wrapped around SQL statements, which will only persist if there are no errors in the block.
This means nothing will be executed until the entire block is valid. The changes happen as one structure, not many pieces.

So for that concurrent request, by wrapping the logic in a `.transaction` block, if the adding of the words fails, it will tell us.

Transactions called be called on a Class method or an instance method, also.
In this refactor, I chose to call the `.transaction` on the `anagram` variable which is the instance of the key found in our Anagram database.
I could call it on the Anagram model itself, but by moving it down to one specific instance of the Anagram class, it catches the specific instance of trying to modify one row of the table at the same time.  

``` ruby
data['words'].each do |word|
  anagram = Anagram.find_or_create_by(key: find_key(word))
  anagram.transaction do
  if anagram.words.exclude?(word)
    anagram.words.push(word)
  end
  anagram.save
  end
end
```

Interestingly, both the `.save` and `.destroy` methods are already wrapped in a transaction in ActiveRecord.
